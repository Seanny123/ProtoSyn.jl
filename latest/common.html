<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common · ProtoSyn.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="ProtoSyn.jl logo"/></a><h1>ProtoSyn.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href="common.html">Common</a><ul class="internal"><li><a class="toctext" href="#Components-1">Components</a></li><li><a class="toctext" href="#Loaders-1">Loaders</a></li><li><a class="toctext" href="#Conformation-Generators-1">Conformation Generators</a></li><li><a class="toctext" href="#Macros-1">Macros</a></li></ul></li><li><a class="toctext" href="forcefield.html">Forcefield</a></li><li><a class="toctext" href="mutators.html">Mutators</a></li><li><a class="toctext" href="drivers.html">Drivers</a></li><li><a class="toctext" href="print.html">Print</a></li><li><a class="toctext" href="aux.html">Aux</a></li><li><a class="toctext" href="json.html">Input JSON Schemas</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="common.html">Common</a></li></ul><a class="edit-page" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/master/docs/src/common.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Common</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Common-1" href="#Common-1">Common</a></h1><h2><a class="nav-anchor" id="Components-1" href="#Components-1">Components</a></h2><p>This section provides a description of the Common components.</p><h3><a class="nav-anchor" id="Energy-1" href="#Energy-1">Energy</a></h3><p>Contains common and simple energy representations. More specific energy structures can be used from other modules such as <a href="forcefield.html#Forcefield-1"><code>Amber</code></a></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.NullEnergy" href="#ProtoSyn.Common.NullEnergy"><code>ProtoSyn.Common.NullEnergy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NullEnergy()</code></pre><p>Empty placeholder energy container.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Common.NullEnergy()
Null</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/energy.jl#L6-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.Energy" href="#ProtoSyn.Common.Energy"><code>ProtoSyn.Common.Energy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Energy(eTotal::Float64)</code></pre><p>Simple energy container.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Common.Energy(1.15)
Energy(eTotal=1.15)

julia&gt; Common.Energy()
Energy(eTotal=0.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/energy.jl#L21-L34">source</a></section><h3><a class="nav-anchor" id="Residue-1" href="#Residue-1">Residue</a></h3><p>In ProtoSyn, a Residue object is a collection of atoms (normally an aminoacid) that are identified by a name, a secondary structure (<a href="common.html#ProtoSyn.Common.SSTYPE"><code>SSTYPE</code></a>) and are part of a continuous tree of other Residues (have a <code>next</code> Residue).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.SSTYPE" href="#ProtoSyn.Common.SSTYPE"><code>ProtoSyn.Common.SSTYPE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SSTYPE</code></pre><p>Enum: holds information regarding the secondary structure of each residue in the simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.Residue" href="#ProtoSyn.Common.Residue"><code>ProtoSyn.Common.Residue</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Residue(atoms::Array{Int64, 1}, next::Union{Residue, Int64, Nothing}, name::String, ss::SecondaryStructureType)</code></pre><p>Define a residue as part of the system.</p><p><strong>Arguments</strong></p><ul><li><code>atoms::Vector{Int64}</code>: list of atom <em>global</em> indices in this residue.</li><li><code>next::Union{Residue, Int64, Nothing}</code>: Next residue in the system, attached to this. Is preferably a Residue instance, but can in certain cases be the index in a Residue list or empty (Nothing).</li><li><code>name::String</code>: Name of the residue. If the residue describes an aminoacid, the correspondent letter is suggested.</li><li><code>ss::SSTYPE</code>: The intitial secondary structure type <a href="common.html#ProtoSyn.Common.SSTYPE"><code>SSTYPE</code></a> of this residue.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Common.Residue([1, 2, 3, 4], Common.Residue([5, 6, 7, 8], nothing, &quot;V&quot;, Common.coil), &quot;E&quot;, Common.alpha)
Common.Residue(atoms=[1, 2, 3, 4], next=V, name=E, ss=alpha)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/residue.jl#L16-L32">source</a></section><h3><a class="nav-anchor" id="Dihedral-1" href="#Dihedral-1">Dihedral</a></h3><p>A Dihedral is a collection of 4 atoms that define a dihedral in the simulated molecule. Many <a href="mutators.html#Mutators-1">Mutators</a> operate over this dihedrals, changing them in order to explore the conformational space of the system. A Dihedral is part of a <a href="common.html#ProtoSyn.Common.Residue"><code>Residue</code></a> and has a defined <a href="common.html#ProtoSyn.Common.DIHEDRALTYPE"><code>DIHEDRALTYPE</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.DIHEDRALTYPE" href="#ProtoSyn.Common.DIHEDRALTYPE"><code>ProtoSyn.Common.DIHEDRALTYPE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DIHEDRALTYPE</code></pre><p>Enum: holds information regarding the dihedral type. ```</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.Dihedral" href="#ProtoSyn.Common.Dihedral"><code>ProtoSyn.Common.Dihedral</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Dihedral(a1::Int64, a2::Int64, a3::Int64, a4::Int64, movable::Array{Int64, 1}, residue::Union{Common.Residue, Int64}, dtype::DIHEDRALTYPE)</code></pre><p>Define a dihedral.</p><p><strong>Arguments</strong></p><ul><li><code>a1::Int64, a2::Int64, a3::Int64, a4::Int64</code>: <em>global</em> atom indices.</li><li><code>movable::Array{Int64, 1}</code>: List of <em>global</em> atom indices that will be moved during the dihedral movement in <em>this</em> residue.</li><li><code>residue::{Residue}</code>: <a href="common.html#ProtoSyn.Common.Residue"><code>Residue</code></a> object that this dihedral belongs to.</li><li><code>dtype::DIHEDRALTYPE</code>: <a href="common.html#ProtoSyn.Common.DIHEDRALTYPE"><code>DIHEDRALTYPE</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dihedral(2, 3, 5, 7, [5, 6], Common.Residue([1, 2, 3, 4, 5, 6], (...), &quot;A&quot;, coil), phi)
Dihedral(a1=2, a2=3, a3=5, a4=7, movable=[5, 6], residue=Common.Residue(atoms=[1, 2, 3, 4, 5, 6], next=V, name=A), type=phi)</code></pre><p>See also: <a href="mutators.html#Mutators-1"><code>Mutators.DihedralMutator</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/dihedral.jl#L22-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.rotate_dihedral!" href="#ProtoSyn.Common.rotate_dihedral!"><code>ProtoSyn.Common.rotate_dihedral!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rotate_dihedral!(xyz::Array{Float64, 2}, dihedral::Dihedral, angle::Float64)</code></pre><p>Perform a dihedral movement, adding the provided <code>angle</code> (in radians). If the <code>dihedral.dtype</code> is &quot;PHI&quot; or &quot;PSI&quot; the <code>dihedral.residue.next</code> is also rotated and this is propagated recursively until the end of the molecule. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Mutators.Dihedral.rotate_dihedral!(state.xyz, dihedral, π/2)</code></pre><p>See also: <a href="mutators.html#Mutators-1"><code>Dihedral</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/dihedral.jl#L52-L64">source</a><div><div><pre><code class="language-none">rotate_dihedral!(xyz::Array{Float64, 2}, a2::Int64, a3::Int64, angle::Float64, dtype::DIHEDRALTYPE, movable::Vector{Int64}[, residue::Union{Residue, Nothing} = nothing])</code></pre><p>Base dihedral movement function. Especifies all arguments used in dihedral rotation movement. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Mutators.Dihedral.rotate_dihedral!(xyz, dihedral.a2, dihedral.a3, π/2, dihedral.dtype, dihedral.movable, dihedral.residue)</code></pre><p>See also: <a href="aux.html#ProtoSyn.Aux.rotation_matrix_from_axis_angle"><code>Aux.rotation_matrix_from_axis_angle</code></a> <a href="mutators.html#Mutators-1"><code>Dihedral</code></a> <a href="mutators.html#Mutators-1"><code>Crankshaft</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/dihedral.jl#L74-L84">source</a></section><h3><a class="nav-anchor" id="Metadata-1" href="#Metadata-1">Metadata</a></h3><p>ProtoSyn Metadata defines additional information of the system that is not necessarily necessary for the basic functions of the library, but allows for a better representation of the system. The <a href="common.html#ProtoSyn.Common.AtomMetadata"><code>AtomMetadata</code></a> structure holds information related to each atom in the system, such as its element, connections, etc</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.AtomMetadata" href="#ProtoSyn.Common.AtomMetadata"><code>ProtoSyn.Common.AtomMetadata</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AtomMetadata(name::String[, elem::String = name, res_num::Int64 = 1, res_name::String = &quot;UNK&quot;, chain_id::Union{String, Nothing} = nothing, connects::Union{Vector{Int64}, Nothing} = nothing])</code></pre><p>Define an atom metadata, containing extra information pertaining the <a href="common.html#ProtoSyn.Common.State"><code>State</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Name of the atom.</li><li><code>elem::String</code>: (Optional) Element of the atom (Default: <code>name</code>).</li><li><code>res_num::Int64</code>: (Optional) Number of the residue this atom belongs to (Default: 1).</li><li><code>res_name::Union{String, Nothing}</code>: (Optional) Name of the residue this atom belongs to (Default: &quot;UNK&quot;).</li><li><code>chain_id::String</code>: (Optional) Name of the chain that contains the residue this atom belongs to (Default: nothing).</li><li><code>connects::Union{Vector{Int64}, Nothing}</code>: (Optional) List of <em>global</em> atom indices that this atom is connected to (Default: nothing). </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; AtomMetadata(&quot;H1&quot;, &quot;H&quot;, 2, &quot;VAL&quot;, &quot;A&quot;, [4])
AtomMetadata(name=H1, elem=H, res_num=2, res_name=VAL, chain_id=A, connects=[4])

julia&gt; AtomMetadata(&quot;H1&quot;)
AtomMetadata(name=H1, elem=H1, res_num=1, res_name=UNK, chain_id=nothing, connects=nothing)</code></pre><p>See also: <a href="common.html#ProtoSyn.Common.iter"><code>iter</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/metadata.jl#L4-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.iter" href="#ProtoSyn.Common.iter"><code>ProtoSyn.Common.iter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iter(data::Vector{AtomMetadata}; property::Symbol = :res_num)</code></pre><p>Iterate over an array of AtomMetadata objects, grouping them based on <code>property</code> (Default: <code>:res_num</code>)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; for residue in iter(state.metadata)
    println(residue)
end
[AtomMetadata(name=H1, elem=H1, res_num=1, res_name=UNK, chain_id=nothing, connects=nothing), AtomMetadata(name=H2, elem=H2, res_num=1, res_name=UNK, chain_id=nothing, connects=nothing)]
[AtomMetadata(name=H3, elem=H3, res_num=2, res_name=UNK, chain_id=nothing, connects=nothing), AtomMetadata(name=H4, elem=H4, res_num=2, res_name=UNK, chain_id=nothing, connects=nothing)]</code></pre><p>See also: <a href="common.html#ProtoSyn.Common.AtomMetadata"><code>AtomMetadata</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/metadata.jl#L58-L72">source</a></section><h3><a class="nav-anchor" id="State-1" href="#State-1">State</a></h3><p>The system state holds information about the current coordinates, energy and forces, aswell as any additional metadata. If iterated over, it returns atom by atom position and metadata.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.State" href="#ProtoSyn.Common.State"><code>ProtoSyn.Common.State</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">State(size::Int64, energy::AbstractEnergy, xyz::Array{Float64, 2}, forces::Array{Float64, 2}, metadata::Vector{AtomMetadata})</code></pre><p>Define the current state of the system, containing the atoms positions, energy and forces applied. If only <code>size::Int64</code> is provided, an empty State with the given <code>size</code> is created with zeros.</p><p><strong>Arguments</strong></p><ul><li><code>size::Int64</code>: Atom count in system.</li><li><code>energy::AbstractEnergy</code>: Current energy of the system (kJ mol⁻¹).</li><li><code>xyz::Array{Float64, 2}</code>: Atom positions in 3 dimensions.</li><li><code>forces::Array{Float64, 2}</code>: Forces applied in each dimension to each atom (kJ mol⁻¹ nm⁻¹)</li><li><code>metadata::Vector{AtomMetadata}</code>: List of atom names.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Common.State(3)
Common.State(size=3, energy=Null, xyz=[0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], forces=[0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], metadata=(...))

julia&gt; Common.State(2, Common.NullEnergy(), [1.1 1.1 1.1; 2.2 2.2 2.2], zeros(2, 3), [AtomMetadata(...), AtomMetadata(...), ...])
Common.State(size=2, energy=Null, xyz=[1.1 1.1 1.1; 2.2 2.2 2.2], forces=[0.0 0.0 0.0; 0.0 0.0 0.0], metadata=(...))</code></pre><p>See also: <a href="common.html#ProtoSyn.Common.AtomMetadata"><code>AtomMetadata</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/state.jl#L4-L26">source</a></section><h3><a class="nav-anchor" id="Callback-1" href="#Callback-1">Callback</a></h3><p>The CallbackObject allows for independent calls to various functions with individual frequency of output. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.CallbackObject" href="#ProtoSyn.Common.CallbackObject"><code>ProtoSyn.Common.CallbackObject</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CallbackObject(freq::Int64, callback::Function)</code></pre><p>Define the callback function parameters.</p><p><strong>Arguments</strong></p><ul><li><code>freq</code>: Frequency (in steps) that the callback function is called.</li><li><code>callback</code>: Actual callback function. This function should have the following signature:</li></ul><pre><code class="language-none">callback(step::Int64, st::Common.State, dr::Drivers.MonteCarlo.MonteCarloDriver, args...)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Common.CallbackObject(100, Print.as_xyz)
CallbackObject(freq=100, callback=Print.as_xyz)

julia&gt; Common.CallbackObject(Print.as_xyz)
CallbackObject(freq=1, callback=Print.as_xyz)</code></pre><p>See also: <a href="print.html#Print-1"><code>Print.as_xyz</code></a> <a href="common.html#ProtoSyn.Common.@cbcall"><code>@cbcall</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/callback.jl#L4-L25">source</a></section><h2><a class="nav-anchor" id="Loaders-1" href="#Loaders-1">Loaders</a></h2><p>This section provides a description on how to load a new <a href="common.html#ProtoSyn.Common.State"><code>State</code></a>, <a href="common.html#ProtoSyn.Common.Residue"><code>Residue</code></a> and <a href="common.html#ProtoSyn.Common.Dihedral"><code>Dihedral</code></a> arrays.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.load_from_gro" href="#ProtoSyn.Common.load_from_gro"><code>ProtoSyn.Common.load_from_gro</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_from_gro(i_file::String)::Common.State</code></pre><p>Return a new <a href="common.html#ProtoSyn.Common.State"><code>Common.State</code></a> by loading the atom positions and names from the input .gro file. As a default, <code>state.energy</code> is <a href="common.html#ProtoSyn.Common.NullEnergy"><code>NullEnergy</code></a> and <code>state.forces</code> are set to zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Common.load_from_gro(&quot;molecule.gro&quot;)
Common.State(size=2, energy=Null, xyz=[1.1 1.1 1.1; 2.2 2.2 2.2], forces=[0.0 0.0 0.0; 0.0 0.0 0.0], atnames=[&quot;C&quot;, &quot;O&quot;])</code></pre><p>See also: <a href="common.html#ProtoSyn.Common.load_from_pdb"><code>load_from_pdb</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/loaders.jl#L5-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.load_from_pdb" href="#ProtoSyn.Common.load_from_pdb"><code>ProtoSyn.Common.load_from_pdb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_from_pdb(i_file::String)::Common.State</code></pre><p>Return a new <a href="common.html#ProtoSyn.Common.State"><code>Common.State</code></a> by loading the atom positions and names from the input .pdb file. As a default, <code>state.energy</code> is <a href="common.html#ProtoSyn.Common.NullEnergy"><code>NullEnergy</code></a> and <code>state.forces</code> are set to zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Common.load_from_pdb(&quot;molecule.pdb&quot;)
Common.State(size=2, energy=Null, xyz=[1.1 1.1 1.1; 2.2 2.2 2.2], forces=[0.0 0.0 0.0; 0.0 0.0 0.0], metadata=(...))</code></pre><p>See also: <a href="common.html#ProtoSyn.Common.load_from_gro"><code>load_from_gro</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/loaders.jl#L40-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.load_topology" href="#ProtoSyn.Common.load_topology"><code>ProtoSyn.Common.load_topology</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_topology(p::Dict{String, Any})</code></pre><p>Parse a dictionary containing the dihedral and residue topology. Return a <a href="common.html#ProtoSyn.Common.Dihedral"><code>Dihedral</code></a> array and a <a href="common.html#ProtoSyn.Common.Residue"><code>Residue</code></a> array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Mutators.Diehdral.load_topology(p)
(ProtoSyn.Mutators.Dihedral.NewDihedral[...], ProtoSyn.Common.Residue[...])</code></pre><p>See also: <a href="aux.html#ProtoSyn.Aux.read_JSON"><code>Aux.read_JSON</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/loaders.jl#L81-L93">source</a></section><h2><a class="nav-anchor" id="Conformation-Generators-1" href="#Conformation-Generators-1">Conformation Generators</a></h2><p>Conformation generators are responsible to change the system <a href="common.html#ProtoSyn.Common.State"><code>State</code></a> in a defined way.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.apply_initial_conf!" href="#ProtoSyn.Common.apply_initial_conf!"><code>ProtoSyn.Common.apply_initial_conf!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">apply_initial_conf!(state::State, dihedrals::Vector{Dihedral})</code></pre><p>Apply predefined angles to all dihedrals defined in <code>dihedrals</code>, based on the <a href="common.html#ProtoSyn.Common.Dihedral"><code>Dihedral</code></a>.residue.ss, changing the State.xyz to apply the secondary structure. The applied angles (in degrees) are the following:</p><p>Beta sheet: PHI = -139.0 | PSI = 135.0 Alpha helix: PHI = -57.0  | PSI = -47.0</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Common.apply_initial_conf(state, dihedrals)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/conf_gen.jl#L1-L16">source</a></section><h2><a class="nav-anchor" id="Macros-1" href="#Macros-1">Macros</a></h2><p>Auxiliary functions that help speed up the system&#39;s performance.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.@cbcall" href="#ProtoSyn.Common.@cbcall"><code>ProtoSyn.Common.@cbcall</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@Common.cbcall callbacks::Tuple{CallbackObject, N} step::Int64 Vararg::Any</code></pre><p>(Macro) Call the CallbackObject.function of each <a href="common.html#ProtoSyn.Common.CallbackObject"><code>CallbackObject</code></a> in the <code>callbacks</code> Tuple{CallbackObject, N} independently. Each CallbackObject.function is ran depending on the defined CallbackObject.freq and the given <code>step</code>. Vararg holds all the arguments necessary to run the callback function itself.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @Common.cbcall (callback_object1, callback_object2) 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/macros.jl#L3-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.@callback" href="#ProtoSyn.Common.@callback"><code>ProtoSyn.Common.@callback</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@Common.callback f::Function freq::Int64</code></pre><p>(Macro) Create a <a href="common.html#ProtoSyn.Common.CallbackObject"><code>CallbackObject</code></a> with the given function <code>f</code> and output frequency <code>freq</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @Common.callback 10 my_callback1
CallbackObject(freq=10, callback=my_callback1)

julia&gt; @Common.callback my_callback1
CallbackObject(freq=1, callback=my_callback1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/macros.jl#L28-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProtoSyn.Common.@faggregator" href="#ProtoSyn.Common.@faggregator"><code>ProtoSyn.Common.@faggregator</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@Common.faggregator name::String f::function Vararg::Any</code></pre><p>(Macro) Aggregate multiple functions <code>f</code> in a single variable <code>name</code>. <code>Vararg</code> contains the arguments used by function <code>f</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @faggregator myeval f top1
@faggregator myeval g top2
@faggregator myeval h top3

energy = myevalf(state, false)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/bd836e76f4a9e93ba666e778f14d21311d3d819c/src/Common/macros.jl#L49-L62">source</a></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="forcefield.html"><span class="direction">Next</span><span class="title">Forcefield</span></a></footer></article></body></html>
