<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · ProtoSyn.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="ProtoSyn.jl logo"/></a><h1>ProtoSyn.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="guide.html">Guide</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="common.html">Common</a></li><li><a class="toctext" href="forcefield.html">Forcefield</a></li><li><a class="toctext" href="mutators.html">Mutators</a></li><li><a class="toctext" href="drivers.html">Drivers</a></li><li><a class="toctext" href="print.html">Print</a></li><li><a class="toctext" href="aux.html">Aux</a></li><li><a class="toctext" href="json.html">Input JSON Schemas</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="guide.html">Guide</a></li></ul><a class="edit-page" href="https://github.com/sergio-santos-group/ProtoSyn.jl/blob/master/docs/src/guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Package-guide-1" href="#Package-guide-1">Package guide</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>Protosyn is still not a registered package. Please download or clone the <a href="https://github.com/sergio-santos-group/ProtoSyn.jl/tree/6233638b9947e5e697c4f2b871b1ea301a6acde5">source</a> code from GitHub.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><p>What follows is a step-by-step guide on how to use the ProtoSyn library.</p><h3><a class="nav-anchor" id="General-overview-and-workflow-1" href="#General-overview-and-workflow-1">General overview and workflow</a></h3><p>ProtoSyn is a stuctural sampling library designed to explore the conformational space of molecules. Specifically, ProtoSyn was developed to study proteins and how they fold in 3D space. With ProtoSyn, the user is able to easily integrate different modules in order to perform distinct actions that change and evaluate the system state.</p><p>The <strong>ProtoSyn Flow</strong> is as follows:</p><ol><li>Load the system initial <a href="common.html#ProtoSyn.Common.State"><code>Common.State</code></a> from a structural file, such as a .pdb or a .gro;</li><li>Load all the necessary topologies, describing the system bonded and non-bonded interactions;</li><li>Choose a <a href="drivers.html#Drivers-1">Driver</a>. This will change the system conformation step after step;</li><li>For certain Drivers, a sampler is required. This function is responsible for mutating the system in a certain way. Several <a href="mutators.html#Mutators-1">Mutators</a> are available.</li><li>Define the evaluating function. Regardless of the Driver chosen, this function will evaluate the system <em>fitness</em> and determine the next step.</li><li>Define the callback function. At this point the user&#39;s program requires a way to comunicate with the outside. Callback functions are employed to output the produced information by the Driver.</li><li>Run the program and do science!</li></ol><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><p>As an example, a Steepest Descent Algorithm written in Julia will be explained in detail. As explained in the <strong>ProtoSyn Flow</strong> we have the following steps:</p><ul><li><strong>Load the system initial <a href="common.html#ProtoSyn.Common.State"><code>Common.State</code></a>.</strong></li></ul><pre><code class="language-julia-repl">julia&gt; state = Common.load_from_pdb(&quot;protein.pdb&quot;)
Common.State(size=56, energy=Null, xyz=[1.1 2.1 1.2; 2.2 1.2 5.2, ...], forces=[0.0 0.0 0.0; 0.0 0.0 0.0, ...], atnames=[&quot;C&quot;, &quot;O&quot;, ...])
julia&gt; state.energy = Forcefield.Energy()</code></pre><ul><li><p><strong>Load all the necessary topologies.</strong></p><p>The topology can be loaded by several ways. ProtoSyn by default expects a JSON file depicting the necessary information. For the Steepest Descent Algorithm, bonds, angles, dihedrals and non-bonded parameters should be depicted in the input JSON file.</p></li></ul><pre><code class="language-julia-repl">julia&gt; topology = Forcefield.load_from_json(&quot;topology.json&quot;)
Forcefield.Topology(
atoms=ProtoSyn.Forcefield.Atom[Forcefield.Atom(name=&quot;N&quot;, σ=0.325, ϵ=0.711, q=0.0017, excls=[0, 1, 2, 3, 4, 5], pairs=[4, 5]), ...],
bonds=ProtoSyn.Forcefield.HarmonicBond[Forcefield.HarmonicBond(a1=1, a2=2, k=2500.0, b0=0.19), ...],
angles=ProtoSyn.Forcefield.HarmonicAngle[Forcefield.HarmonicAngle(a1=1, a2=2, a3=3, k=670.0, θ=1.92), ...],
dihedralsCos=ProtoSyn.Forcefield.DihedralCos[Forcefield.DihedralCos(a1=1, a2=2, a3=3, a4=4, k=10.46, θ=180.0, mult=2.0), ...])</code></pre><ul><li><p><strong>Choose a <a href="drivers.html#Drivers-1">Driver</a>.</strong></p><p>This step includes loading the necessary runtime parameters. These are specific to the chosen Driver.</p></li></ul><pre><code class="language-julia-repl">julia&gt; params = Drivers.SteepestDescent.ConfigParameters(10000, 100, 1e-3, 0.1)
Drivers.SteepestDescent.ConfigParameters(n_steps=10000, log_freq=100, f_tol=1e-3, max_step=0.1)</code></pre><ul><li><p><strong>Define the sampler.</strong></p><p>As stated in the <a href="drivers.html#Drivers-1">documentation</a>, the Steepest Descent Driver does not require a sampler, as the Driver itself is responsible for choosing the next step without the aid of a <a href="mutators.html#Mutators-1">Mutator</a>.</p></li><li><p><strong>Define the evaluating function.</strong></p><p>When defining the necessary functions in ProtoSyn, careful care needs to be taken to match the expected function signature, described in the <a href="drivers.html#Drivers-1">documentation</a>.</p></li></ul><pre><code class="language-julia-repl">julia&gt; function my_evaluator!(st::Common.State, do_forces::Bool)
        return Forcefield.evalenergy!(topology, st, cut_off=1.2, do_forces=do_forces)
    end
my_evaluator! (generic function with 1 method)</code></pre><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>Even though the <code>my_evaluator!</code> function does not directly receive the topology as an argument, it is still able to access it as it was defined in the main body of our program.</p></div></div><ul><li><p><strong>Define the callback function.</strong></p><p>Altough optional, this function allows the user to easily retrieve the information being produced by the Driver. ProtoSyn includes some functions for this, such as to <a href="print.html#Print-1">Print</a> the current state to a structural file.</p></li></ul><pre><code class="language-julia-repl">julia&gt; output = open(&quot;output.xyz&quot;, &quot;w&quot;)
IOStream(&lt;output.xyz&gt;)
julia&gt; function my_callback(st::Common.State, step::Int)
            Print.as_xyz(st, ostream = output, title = &quot;Step $step&quot;)
        end
my_callback (generic function with 1 method)</code></pre><ul><li><p><strong>Run the program and do science!</strong></p><p>All the necessary variables and functions have been defined in the main body of our program and it is ready to be deployed.</p></li></ul><pre><code class="language-julia-repl">julia&gt; Drivers.SteepestDescent.run!(state, my_evaluator!, params, callback = my_callback)</code></pre><p>For more detailed information, please reference to the Manual.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="common.html"><span class="direction">Next</span><span class="title">Common</span></a></footer></article></body></html>
