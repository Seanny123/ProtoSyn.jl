var documenterSearchIndex = {"docs":
[{"location":"core/builder/#","page":"Builder","title":"Builder","text":"CurrentModule = Builder","category":"page"},{"location":"core/builder/#Builder-1","page":"Builder","title":"Builder","text":"","category":"section"},{"location":"core/builder/#","page":"Builder","title":"Builder","text":"build\n@seq_str\nopfactory\nlgfactory","category":"page"},{"location":"core/builder/#ProtoSyn.Builder.build","page":"Builder","title":"ProtoSyn.Builder.build","text":"build([T=Float64,] grammar::LGrammar, derivation)\n\nBuild a Pose{Topology}.\n\n\n\n\n\n","category":"function"},{"location":"core/builder/#ProtoSyn.Builder.@seq_str","page":"Builder","title":"ProtoSyn.Builder.@seq_str","text":"@seq_str -> Vector{String}\n\nConstruct a vector of strings from the provided string. \n\nExamples\n\njulia> seq\"ABC\"\n3-element Array{String,1}:\n \"A\"\n \"B\"\n \"C\"\n\n\n\n\n\n","category":"macro"},{"location":"core/builder/#ProtoSyn.Builder.opfactory","page":"Builder","title":"ProtoSyn.Builder.opfactory","text":"opfactory(args) -> Function\n\nClosure\n\n\n\n\n\n","category":"function"},{"location":"core/builder/#ProtoSyn.Builder.lgfactory","page":"Builder","title":"ProtoSyn.Builder.lgfactory","text":"lgfactory([T=Float64,] template::Dict) -> LGrammar{String,Vector{String}}\n\nExample\n\namylose:\n  rules:\n    A:\n      - {p: 0.75, production: [A,α,A]}\n      - {p: 0.25, production: [B,\"[\",α,A,\"]\",β,A]}\n  variables:\n    A: resources/Sugars/GLC14.pdb\n  operators:\n    α14:\n      residue1: C1\n      residue2: O4\n      presets:\n        O4: {θ: 127, ϕ: -90.712, b: 1.43}\n        C4: {θ: 100, ϕ: -103.475}\n      offsets:\n        H4: 0\n  defop: α14\n\n\n\n\n\n","category":"function"},{"location":"manual/getting-started/#man-getting-started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"manual/getting-started/#","page":"Getting Started","title":"Getting Started","text":"Hi there","category":"page"},{"location":"core/graph/#Graph-1","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"core/graph/#","page":"Graph","title":"Graph","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"core/graph/#","page":"Graph","title":"Graph","text":"AbstractDigraph\nhasparent\nhaschildren\nisparent\nsetparent!\npopparent!\npopchild!\nadjacency\nbfs","category":"page"},{"location":"core/graph/#ProtoSyn.AbstractDigraph","page":"Graph","title":"ProtoSyn.AbstractDigraph","text":"AbstractDigraph\n\nSupertype for a directed graph node.\n\n\n\n\n\n","category":"type"},{"location":"core/graph/#ProtoSyn.hasparent","page":"Graph","title":"ProtoSyn.hasparent","text":"hasparent(c::AbstractDigraph) -> Bool\n\nTest whether the given AbstractDigraph c has a parent.\n\n\n\n\n\n","category":"function"},{"location":"core/graph/#ProtoSyn.haschildren","page":"Graph","title":"ProtoSyn.haschildren","text":"haschildren(c::AbstractDigraph) -> Bool\n\nTest whether the given AbstractDigraph c has children.\n\n\n\n\n\n","category":"function"},{"location":"core/graph/#ProtoSyn.isparent","page":"Graph","title":"ProtoSyn.isparent","text":"isparent(p::AbstractDigraph, c::AbstractDigraph) -> Bool\n\nTest whether p is the parent of c.\n\n\n\n\n\n","category":"function"},{"location":"core/graph/#ProtoSyn.setparent!","page":"Graph","title":"ProtoSyn.setparent!","text":"setparent!(c::T, p::T) where {T<:AbstractDigraph}\n\nSet p as the parent of c.\n\n\n\n\n\n","category":"function"},{"location":"core/graph/#ProtoSyn.popparent!","page":"Graph","title":"ProtoSyn.popparent!","text":"popparent!(c::AbstractDigraph}\n\nRemove the parent from c and make c orphan.\n\n\n\n\n\n","category":"function"},{"location":"core/graph/#ProtoSyn.popchild!","page":"Graph","title":"ProtoSyn.popchild!","text":"popchild!(p::AbstractDigraph} -> child\n\nRemove a child from p and return it. The returned element is orphan. Return nothing if the item has no children.\n\n\n\n\n\n","category":"function"},{"location":"core/graph/#ProtoSyn.adjacency","page":"Graph","title":"ProtoSyn.adjacency","text":"adjacency(p::AbstractDigraph)\n\nBuild and return the adjacency list for all nodes reachable from p.\n\n\n\n\n\n","category":"function"},{"location":"core/graph/#ProtoSyn.bfs","page":"Graph","title":"ProtoSyn.bfs","text":"function bfs(f::Function, c::T) where {T <: AbstractDigraph} -> Nothing\n\nPerform a breadth-first search starting from c and call function f on each visited node.\n\n\n\n\n\n","category":"function"},{"location":"core/types/#","page":"Types","title":"Types","text":"CurrentModule = ProtoSyn","category":"page"},{"location":"core/types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"core/types/#","page":"Types","title":"Types","text":"This section list all core types defined in ProtoSyn.","category":"page"},{"location":"core/types/#","page":"Types","title":"Types","text":"","category":"page"},{"location":"core/types/#","page":"Types","title":"Types","text":"note: Note\nThis is a Note","category":"page"},{"location":"core/types/#Containers-1","page":"Types","title":"Containers","text":"","category":"section"},{"location":"core/types/#","page":"Types","title":"Types","text":"All container types are subtypes of AbstractContainer{T} and AbstractDigraph","category":"page"},{"location":"core/types/#","page":"Types","title":"Types","text":"using ProtoSyn","category":"page"},{"location":"core/types/#","page":"Types","title":"Types","text":"Atom <: ProtoSyn.AbstractContainer\nAtom <: ProtoSyn.AbstractDigraph","category":"page"},{"location":"core/types/#","page":"Types","title":"Types","text":"Atom","category":"page"},{"location":"core/types/#ProtoSyn.Atom","page":"Types","title":"ProtoSyn.Atom","text":"Atom <: AbstractAtom\n\nAn Atom type.\n\nAtom(name::String, id::Int, index::Int, symbol::String)\n\nConstruct an Atom, with the given name, id, index, and symbol. The created atom has no bonds and container; it is also a free directed-graph node.\n\nExamples\n\njulia> at = Atom(\"H1\", 1, 1, \"H\")\nAtom{/H1:1}\n\njulia> hascontainer(at), isempty(at.bonds)\n(false, true)\n\njulia> hasparent(at), haschildren(at)\n(false, false)\n\n\n\n\n\n","category":"type"},{"location":"core/types/#Abstract-types-1","page":"Types","title":"Abstract types","text":"","category":"section"},{"location":"core/types/#","page":"Types","title":"Types","text":"AbstractContainer","category":"page"},{"location":"core/types/#ProtoSyn.AbstractContainer","page":"Types","title":"ProtoSyn.AbstractContainer","text":"AbstractContainer{T} <: AbstractDigraph\n\nSupertype for a container of elements of type T, implementing the AbstractDigraph interface.\n\n\n\n\n\n","category":"type"},{"location":"peptides/#","page":"Peptides","title":"Peptides","text":"CurrentModule = Peptides","category":"page"},{"location":"peptides/#Peptides-1","page":"Peptides","title":"Peptides","text":"","category":"section"},{"location":"peptides/#","page":"Peptides","title":"Peptides","text":"isproline\nbuild_graph!\ngrammar\nsetss!","category":"page"},{"location":"peptides/#ProtoSyn.Peptides.isproline","page":"Peptides","title":"ProtoSyn.Peptides.isproline","text":"isproline(r::Residue) -> Bool\n\nDetermine if a residue is a proline.\n\n\n\n\n\n","category":"function"},{"location":"peptides/#ProtoSyn.Peptides.build_graph!","page":"Peptides","title":"ProtoSyn.Peptides.build_graph!","text":"build_graph!(top::Topology)\n\nUtility function for building the atom and residue graphs of peptides. The root atom of the atom graph for each segment is taken as the N of the first residue of each segment.\n\n\n\n\n\n","category":"function"},{"location":"peptides/#ProtoSyn.Peptides.grammar","page":"Peptides","title":"ProtoSyn.Peptides.grammar","text":"grammar([T=Float64,] dir::AbstractString=resource_dir)\n\nBuild a LGrammar for peptides, taking as variables the fragments in dir. The peptidejoin function is included as the default operator. The returned L-grammar is required for building peptides from fragments.\n\nExamples\n\njulia> g = Peptides.grammar();\njulia> pose = Builder.build(grammar, \"AAGASTASSE\")\n...\n\n!!! NOTE     requires update\n\n\n\n\n\n","category":"function"},{"location":"peptides/#ProtoSyn.Peptides.setss!","page":"Peptides","title":"ProtoSyn.Peptides.setss!","text":"setss!(pose::Pose, (ϕ, ψ, ω)::NTuple{3,Number})\n\nSet the ϕ, ψ and ω backbone angles of all residues in the given pose. This function is usefull for setting the secondary structure of a pose. This function acts on the internal coordinates and does not update cartesian coordinates, although a request for conversion is made. It is up to the calling function/user to explicitly synchornize coordinates via sync!. \n\n\n\n\n\n","category":"function"},{"location":"peptides/#","page":"Peptides","title":"Peptides","text":"","category":"page"},{"location":"peptides/#","page":"Peptides","title":"Peptides","text":"Modules = [Peptides]","category":"page"},{"location":"peptides/#ProtoSyn.Peptides.grammar-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Peptides","title":"ProtoSyn.Peptides.grammar","text":"grammar([T=Float64,] dir::AbstractString=resource_dir)\n\nBuild a LGrammar for peptides, taking as variables the fragments in dir. The peptidejoin function is included as the default operator. The returned L-grammar is required for building peptides from fragments.\n\nExamples\n\njulia> g = Peptides.grammar();\njulia> pose = Builder.build(grammar, \"AAGASTASSE\")\n...\n\n!!! NOTE     requires update\n\n\n\n\n\n","category":"method"},{"location":"peptides/#ProtoSyn.Peptides.isproline-Tuple{Residue}","page":"Peptides","title":"ProtoSyn.Peptides.isproline","text":"isproline(r::Residue) -> Bool\n\nDetermine if a residue is a proline.\n\n\n\n\n\n","category":"method"},{"location":"peptides/#ProtoSyn.Peptides.setss!-Tuple{Pose,Tuple{Number,Number,Number}}","page":"Peptides","title":"ProtoSyn.Peptides.setss!","text":"setss!(pose::Pose, (ϕ, ψ, ω)::NTuple{3,Number})\n\nSet the ϕ, ψ and ω backbone angles of all residues in the given pose. This function is usefull for setting the secondary structure of a pose. This function acts on the internal coordinates and does not update cartesian coordinates, although a request for conversion is made. It is up to the calling function/user to explicitly synchornize coordinates via sync!. \n\n\n\n\n\n","category":"method"},{"location":"peptides/#ProtoSyn.Peptides.build_graph!-Tuple{Topology}","page":"Peptides","title":"ProtoSyn.Peptides.build_graph!","text":"build_graph!(top::Topology)\n\nUtility function for building the atom and residue graphs of peptides. The root atom of the atom graph for each segment is taken as the N of the first residue of each segment.\n\n\n\n\n\n","category":"method"},{"location":"sugars/#","page":"Sugars","title":"Sugars","text":"CurrentModule = Sugars","category":"page"},{"location":"sugars/#Sugars-1","page":"Sugars","title":"Sugars","text":"","category":"section"},{"location":"sugars/#","page":"Sugars","title":"Sugars","text":"This module provides the the functionalities for building and manipulating sugars.","category":"page"},{"location":"sugars/#","page":"Sugars","title":"Sugars","text":"amylose:\n  rules:\n    A:\n      - {p: 1.0, production: [A,α,A]}\n  variables:\n    A: resources/Sugars/yml/glu14.yml\n  defop: α\n  operators:\n    α:\n      residue1: C1\n      residue2: O4\n      presets:\n        O4:\n          θ:  2.2165681500327987  # 127 deg\n          ϕ: -1.5832230710690962  # -90.712 deg\n          b:  1.43\n        C4:\n          θ:  1.7453292519943295  # 100 deg\n          ϕ: -1.8059794435011325  # -103.475 deg\n      offsets:\n        H4: 0","category":"page"},{"location":"sugars/#load-stuff-1","page":"Sugars","title":"load stuff","text":"","category":"section"},{"location":"sugars/#","page":"Sugars","title":"Sugars","text":"grammar","category":"page"},{"location":"sugars/#ProtoSyn.Sugars.grammar","page":"Sugars","title":"ProtoSyn.Sugars.grammar","text":"grammar([T=Float64,] polyname::String)\n\nBuild a LGrammar for polysaccharide polyname from the grammars.yml file available in the Sugars resource directory. The returned L-grammar can then be used by the Builder.build function to build the polymer.\n\nExamples\n\njulia> g = Sugars.grammar(\"amylose\");\njulia> pose = Builder.build(g, \"AAA\")\n...\n\n\n\n\n\n","category":"function"},{"location":"core/#ProtoSyn-1","page":"ProtoSyn","title":"ProtoSyn","text":"","category":"section"},{"location":"core/#","page":"ProtoSyn","title":"ProtoSyn","text":"core documentation lives here","category":"page"},{"location":"manual/#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"this is where general information documenting how ProtoSyn works will live.","category":"page"},{"location":"xmlrpc/#XMLRPC-1","page":"XMLRPC","title":"XMLRPC","text":"","category":"section"},{"location":"xmlrpc/#","page":"XMLRPC","title":"XMLRPC","text":"CurrentModule = ProtoSyn.XMLRPC","category":"page"},{"location":"xmlrpc/#","page":"XMLRPC","title":"XMLRPC","text":"ServerProxy","category":"page"},{"location":"xmlrpc/#ProtoSyn.XMLRPC.ServerProxy","page":"XMLRPC","title":"ProtoSyn.XMLRPC.ServerProxy","text":"ServerProxy(host::String, port::Int)\n\nInstantiate a server proxy listening on hostand  port. This object is meant to act as a proxy to a remote service implementing the XML/RPC protocol, and was designed to work with PyMOL.\n\n\n\n\n\n","category":"type"},{"location":"#PROTOSYN-1","page":"PROTOSYN","title":"PROTOSYN","text":"","category":"section"},{"location":"#","page":"PROTOSYN","title":"PROTOSYN","text":"WORK IN PROGRESS!","category":"page"}]
}
