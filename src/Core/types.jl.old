export Opt
export Atom, Residue, Segment, Topology
export AtomGraphNode, ResidueGraphNode

const Opt = Union{Nothing, T} where T

# should implemente the name and id fields
abstract type AbstractIdentifiable end

# should implement the items[], container and size fields
abstract type AbstractContainer{T} <: AbstractIdentifiable end

abstract type AbstractAtom <: AbstractContainer{Nothing} end
abstract type AbstractResidue <: AbstractContainer{AbstractAtom} end
abstract type AbstractSegment <: AbstractContainer{AbstractResidue} end
abstract type AbstractTopology <: AbstractContainer{AbstractSegment} end

# abstract type AbstractAtom <: AbstractIdentifiable end
# abstract type AbstractResidue <: AbstractIdentifiable end
# abstract type AbstractSegment <: AbstractIdentifiable end
# abstract type AbstractTopology <: AbstractIdentifiable end

Base.push!(container::AbstractContainer{T}, item::T) where T = begin
    if item âˆ‰ container
        push!(container.items, item)
        item.container = container
        container.size += 1
    end
    parent
end

#-------------------------------------------------------------------------------
#region GraphNode
mutable struct GraphNode{T<:AbstractIdentifiable}
    item::T
    parent::Opt{GraphNode{T}}
    children::Vector{GraphNode{T}}
    visited::Bool
    ascendents::Opt{NTuple{4,Int}}
end

GraphNode{T}(item::T) where T = 
    GraphNode(item, nothing, GraphNode{T}[], false, nothing)

#endregion GraphNode


#-------------------------------------------------------------------------------
#region Identifiables
mutable struct Atom <: AbstractAtom
    name::String                    # atom name
    id::Int                         # atom ID
    index::Int                      # global atom index (1-based)
    symbol::String                  # element symbol
    bonds::Vector{Atom}             # list of connected atoms
    residue::Opt{AbstractResidue}   # parent residue
    node::GraphNode{Atom}           #
    Atom(name::String, id::Int, index::Int, symbol::String) = begin
        at = new(name, id, index, symbol, Atom[], nothing)
        at.node = GraphNode{Atom}(at)
        at
    end
end

mutable struct Residue <: AbstractResidue
    name::String                    # residue name
    id::Int                         # residue ID
    atoms::Vector{Atom}             # list of atoms (children)
    atomsbyname::Dict{String, Atom} # child atoms indexed by name
    segment::Opt{AbstractSegment}   # parent segment
    size::Int
    node::GraphNode{Residue}        #
    Residue(name::String, id::Int) = begin
        r = new(name, id, Atom[], Dict{String,Atom}(), nothing, 0)
        r.node = GraphNode{Residue}(r)
        r
    end
end

mutable struct Segment <: AbstractSegment
    name::String                    # segment name
    id::Int                         # segment ID
    residues::Vector{Residue}       # list of residues (children)
    topology::Opt{AbstractTopology} # parent topology
    size::Int
    Segment(name::String, id::Int) = begin
        new(name, id, Residue[], nothing, 0)
    end
end

mutable struct Topology <: AbstractTopology
    name::String
    id::Int
    segments::Vector{Segment}
    size::Int
    root::Residue
    Topology(name::String, id::Int) = begin
        root = Residue("ROOT", -1)
        y = Atom("Y", -1, -2, "?")
        x = Atom("X", -2, -1, "?")
        o = Atom("O", -3,  0, "?")
        push!(y.node, x.node)
        push!(x.node, o.node)
        push!(root, y, x, o)
        new(name, id, Segment[], 0, root)
    end
end

#endregion Identifiable

const AtomGraphNode = GraphNode{Atom}
const ResidueGraphNode = GraphNode{Residue}
