export eachatom, eachresidue

#region Iterators --------------------------------------------------------------
const _ByAtom = Val{1}
const _ByResidue = Val{2}

struct ItemIterator{T <: AbstractIdentifiable,B}
    target::T
    size::Tuple{Vararg{Int}}
end

Base.length(iter::ItemIterator{T,B}) where {T,B} = iter.size[end]
Base.size(iter::ItemIterator{T,B}) where {T,B} = iter.size

Base.show(io::IO,iter::ItemIterator{T,_ByAtom}) where T = begin
    println(io, "ItemIterator{$(nameof(T)), _ByAtom} with size $(iter.size)")
end
Base.show(io::IO,iter::ItemIterator{T,_ByResidue}) where T = begin
    println(io, "ItemIterator{$(nameof(T)), _ByResidue} with size $(iter.size)")
end

#region AtomIterator -----------------------------------------------------------

eachatom(t::Topology) = begin
    nres = mapreduce(s->s.size, +, t.segments; init=0)
    natm = mapreduce(s->mapreduce(r->r.size, +, s.residues; init=0), +, t.segments; init=0)
    ItemIterator{Topology,_ByAtom}(t, (t.size,nres,natm))
    # nseg = length(t.segments)
    # nres = mapreduce(s->length(s.residues), +, t.segments)
    # natm = mapreduce(s->mapreduce(r->length(r.atoms), +, s.residues), +, t.segments)
    # ItemIterator{Topology,_ByAtom}(t, (nseg,nres,natm))
end

eachatom(s::Segment) = begin
    natm = mapreduce(r->r.size, +, s.residues; init=0)
    ItemIterator{Segment,_ByAtom}(s, (s.size,natm))
    # nres = length(s.residues)
    # natm = mapreduce(r->length(r.atoms), +, s.residues)
    # ItemIterator{Segment,_ByAtom}(s, (nres,natm))
end

eachatom(r::Residue) = begin
    # natm = length(r.atoms)
    # ItemIterator{Residue,_ByAtom}(r, (natm,))
    ItemIterator{Residue,_ByAtom}(r, (r.size,))
end


Base.iterate(iter::ItemIterator{Topology,_ByAtom}, (s,r,a)=(1,1,1)) = begin
    t = iter.target
    if s > length(t.segments)
        return nothing
    elseif r > length(t.segments[s].residues)
        return iterate(iter, (s+1,1,1))
    elseif a > length(t.segments[s].residues[r].atoms)
        return iterate(iter, (s,r+1,1))
    end
    (t.segments[s].residues[r].atoms[a], (s,r,a+1))
end

Base.iterate(iter::ItemIterator{Segment,_ByAtom}, (r,a)=(1,1)) = begin
    s = iter.target
    if r > length(s.residues)
        return nothing
    elseif a > length(s.residues[r].atoms)
        return iterate(iter, (r+1,1))
    end
    (s.residues[r].atoms[a], (r,a+1))
end

Base.iterate(iter::ItemIterator{Residue,_ByAtom}, (a,)=(1,)) = begin
    r = iter.target
    if a > length(r.atoms)
        return nothing
    end
    (r.atoms[a], (a+1,))
end
#endregion AtomIterator


#region ResidueIterator --------------------------------------------------------

eachresidue(t::Topology) = begin
    nres = mapreduce(s->s.size, +, t.segments; init=0)
    ItemIterator{Topology,_ByResidue}(t, (t.size,nres))
    # nseg = length(t.segments)
    # nres = mapreduce(s->length(s.residues), +, t.segments)
    # ItemIterator{Topology,_ByResidue}(t, (nseg,nres))
end

eachresidue(s::Segment) = begin
    ItemIterator{Segment,_ByResidue}(s, (s.size,))
    # nres = length(s.residues)
    # ItemIterator{Segment,_ByResidue}(s, (nres,))
end

Base.iterate(iter::ItemIterator{Topology,_ByResidue}, (s,r)=(1,1)) = begin
    t = iter.target
    if s > length(t.segments)
        return nothing
    elseif r > length(t.segments[s].residues)
        return iterate(iter, (s+1,1))
    end
    (t.segments[s].residues[r], (s,r+1))
end
#region ResidueIterator


#endregion Iterators